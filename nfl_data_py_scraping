{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "e0c77669",
   "metadata": {
    "heading_collapsed": true
   },
   "source": [
    "## imports, general functions, save/read-in data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f1f050d3",
   "metadata": {
    "code_folding": [
     1
    ],
    "hidden": true
   },
   "outputs": [],
   "source": [
    "# imports and installs\n",
    "try :\n",
    "    import pandas as pd\n",
    "    import numpy as np\n",
    "    import matplotlib.pyplot as plt\n",
    "    from simple_colors import * # for printing in red when debugging\n",
    "    import nfl_data_py as nfl #\n",
    "\n",
    "    # import itertools # \n",
    "    # from difflib import SequenceMatcher # string similarity\n",
    "    # import string # for \n",
    "    # from nba_api.stats.endpoints import playbyplayv2, scoreboard\n",
    "    # import requests\n",
    "    import warnings\n",
    "    import os\n",
    "    \n",
    "except Exception as e : print(red(e))    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "23dc2f8a",
   "metadata": {
    "code_folding": [
     0,
     7,
     17
    ],
    "hidden": true
   },
   "outputs": [],
   "source": [
    "# online functions ; display_side_by_side & similar\n",
    "# turn 1 to 1st, 2 to 2nd, etc.\n",
    "ordinal = lambda n: \"%d%s\" % (n,\"tsnrhtdd\"[(n//10%10!=1)*(n%10<4)*n%10::4])\n",
    "\n",
    "# define display_side_by_side(df1,df2, titles) side-by side\n",
    "from IPython.display import display_html\n",
    "from itertools import chain,cycle\n",
    "def display_side_by_side(*args,titles=cycle([''])):\n",
    "    html_str=''\n",
    "    for df,title in zip(args, chain(titles,cycle(['</br>'])) ):\n",
    "        html_str+='<th style=\"text-align:center\"><td style=\"vertical-align:top\">'\n",
    "        html_str+=f'<h2>{title}</h2>'\n",
    "        html_str+=df.to_html().replace('table','table style=\"display:inline\"')\n",
    "        html_str+='</td></th>'\n",
    "    display_html(html_str,raw=True)\n",
    "    \n",
    "# def similar(a, b):\n",
    "def similar(a, b):\n",
    "    return SequenceMatcher(None, a, b).ratio()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "id": "79ee793c",
   "metadata": {
    "code_folding": [
     7,
     34
    ],
    "deletable": false,
    "editable": false,
    "hidden": true,
    "run_control": {
     "frozen": true
    }
   },
   "outputs": [],
   "source": [
    "# def read_and_save_data():\n",
    "def read_and_save_data():\n",
    "    create_save_dfs()\n",
    "    \n",
    "# def create_save_dfs():\n",
    "# input : N/A, just one time run to import in data\n",
    "# output : N/A, read in data from nfl.import functions and save to appropriate folders\n",
    "def create_save_dfs():\n",
    "    warnings.filterwarnings('ignore')   \n",
    "    # prepare years to loop through\n",
    "    ystart = 2000 ; yend = 2024\n",
    "    years = np.linspace(ystart,yend, yend-ystart+1, dtype = int)\n",
    "\n",
    "    sp = r\"C:\\Users\\Rafal Adamczyk\\Documents\\portfolio projects\\(2)_NFL\"\n",
    "    # loop through recent years and save to dataframe\n",
    "    for y in years:\n",
    "        # run nfl.import functions for relevant data\n",
    "        try : \n",
    "            # create savepath to specific year\n",
    "            savepath = sp + \"\\\\\" + str(y)\n",
    "            # get relevant data\n",
    "            yearly_dfs[ f\"data_{y}\" ] = {f\"pbp_{y}\" : nfl.import_pbp_data([y]),\n",
    "                                         f\"players_{y}\" : nfl.import_rosters([y]),\n",
    "                                         f\"teams_{y}\" : nfl.import_team_desc() } \n",
    "            # save to folder to read in quicker rather than importing\n",
    "            save_to_path(yearly_dfs[ f\"data_{y}\" ], savepath)\n",
    "            print(f'Data from {y} saved.')\n",
    "        except Exception as e: print(f'Error in create_save_dfs() ; {e}')\n",
    "    warnings.filterwarnings('default')\n",
    "    \n",
    "# def save_to_paxth(dict_y, savepath):\n",
    "# input dict_y : (dict) dict of relvant dfs for appropriate year ; yearly_dfs[ f\"data_{y}\" ] in create_save_dfs()\n",
    "# input savepath : (str) path to folder to create yearly NFL folders and save data\n",
    "# output : N/A, just save dataframes to file directory\n",
    "def save_to_path(dict_y, savepath):\n",
    "    # check if path exists and is a directory (folder)\n",
    "    e = os.path.exists(savepath)\n",
    "    f = os.path.isdir(savepath)\n",
    "    # if folder already exists, save in relevant dataframes\n",
    "    if (e) & (f):\n",
    "        folder = savepath + \"\\\\\"\n",
    "        for key,val in dict_y.items() :\n",
    "            val.to_csv(folder + key + \".csv\")                \n",
    "    # if proper folders don't exist, create them and rerun function to save dfs in there\n",
    "    else :\n",
    "        os.makedirs(savepath)\n",
    "        return save_to_path(exdf, savepath)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "66e28750",
   "metadata": {
    "deletable": false,
    "editable": false,
    "hidden": true,
    "run_control": {
     "frozen": true
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2000 done.\n",
      "Downcasting floats.\n",
      "Data from 2000 saved.\n",
      "2001 done.\n",
      "Downcasting floats.\n",
      "Data from 2001 saved.\n",
      "2002 done.\n",
      "Downcasting floats.\n",
      "Data from 2002 saved.\n",
      "2003 done.\n",
      "Downcasting floats.\n",
      "Data from 2003 saved.\n",
      "2004 done.\n",
      "Downcasting floats.\n",
      "Data from 2004 saved.\n",
      "2005 done.\n",
      "Downcasting floats.\n",
      "Data from 2005 saved.\n",
      "2006 done.\n",
      "Downcasting floats.\n",
      "Data from 2006 saved.\n"
     ]
    }
   ],
   "source": [
    "read_and_save_data()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3d58b028",
   "metadata": {},
   "source": [
    "## beginning analyses"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "87ccc7d9",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d95533bb",
   "metadata": {
    "code_folding": []
   },
   "outputs": [],
   "source": [
    "# (ex code)\n",
    "df_2021 = nfl.import_pbp_data([2021])\n",
    "df_players = nfl.import_rosters([2021])\n",
    "df_teams = nfl.import_team_desc()\n",
    "\n",
    "# filter to regular season\n",
    "df_2021 = df_2021[df_2021[\"season_type\"] == \"REG\"]\n",
    "# remove two point attempts\n",
    "df_2021 = df_2021[df_2021[\"two_point_attempt\"] == False]\n",
    "# filter to pass plays\n",
    "df_2021 = df_2021[df_2021[\"play_type\"] == \"pass\"]\n",
    "# join with the roster table to get player names\n",
    "df_2021 = df_2021.merge(df_players[[\"player_id\", \"player_name\"]], left_on=\"passer_player_id\", right_on=\"player_id\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
